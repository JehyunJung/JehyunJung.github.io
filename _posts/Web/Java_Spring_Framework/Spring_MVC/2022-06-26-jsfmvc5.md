---
title: "Java Spring MVC part 5"
excerpt: "Spring MVC Http Functions"

categories:
  - Web
tags:
  - Java_Spring
  - inflearn
---
# Basic HTTP Request, Response with SpringMVC

## SLF4J Logger

spring boot에서는 기본적으로 SLF4J 방식의 인터페이스를 제공하며, 내부적으로 LogBack 라이브러리를 로거로 사용한다.

Logger을 이용해서 로그를 남기게 되면 System.out.println과 달리 다양한 기능들을 활용할 수 있다.

```java
private final Logger log=LoggerFactory.getLogger(getClass());
@RequestMapping("/log-test")
public String logTest(){
    String name = "Spring";

    System.out.println("name = " + name);
    log.trace("trace log={}",name);
    log.debug("debug log={}",name);
    log.info("info log={}",name);
    log.warn("warn log={}",name);
    log.error("error log={}",name);
    
    return "ok";
}
```
>@RestController
위와 같이 @Controller가 아닌, @RestController로 실행하게 되면 메소드의 반환값으로 뷰를 찾지 않고 바로 HTTP Body에 값을 추가해서 HTTP Response를 보내게 된다.

Logger을 이용하게 되면 로그 레벨 설정을 통한 로그 출력이 가능하다.

로그 레벨은 TRACE> DEBUG> INFO> WARN> ERROR 으로 이루어 져있는데, 로그레벨을 설정하게 되면 상위 레벨을 출력이 되지 않는다.
보통 개발 환경에서는 DEBUG 레벨을, 운영환경에서는 INFO 레벨로 설정해서 로그를 남긴다.

> application.properties

```java
//전체 로그 레벨 설정(기본 info)
logging.level.root=info

//hello.springmvc 패키지와 그 하위 로그 레벨 설정
logging.level.hello.springmvc=debug
```

application.properties에서 로그 레벨을 지정할 수 있다. 위와 같이 설정할 경우 springmvc 하위의 패키지에 대해서는 debug 레벨로 설정되어 아래와 같이 TRACE를 제외한 모든 로고가 출력된다.

```powershell
2022-06-27 21:32:54.511 DEBUG 14952 --- [nio-8080-exec-1] hello.springmvc.basic.LogTestController  : debug log=Spring
2022-06-27 21:32:54.512  INFO 14952 --- [nio-8080-exec-1] hello.springmvc.basic.LogTestController  : info log=Spring
2022-06-27 21:32:54.512  WARN 14952 --- [nio-8080-exec-1] hello.springmvc.basic.LogTestController  : warn log=Spring
2022-06-27 21:32:54.512 ERROR 14952 --- [nio-8080-exec-1] hello.springmvc.basic.LogTestController  : error log=Spring
```

```java
log.debug("data="+data);
log.debug("data={}",data);
```
로그는 위의 두가지 방식 모두 지원하는데, 첫번째 방식은 완전한 문자열을 인자로 전달했고, 두번째 방식은 파라미터를 이용해서 로그를 만들었다. 

만약, 로그 레벨이 INFO로 설정되어 있게 되면, 첫번째 방식으로는 문자열 연산은 발생하지만 로그는 출력되지 않고, 두번째 방식에서는 아무런 동작을 수행하지 않는다. 즉, 첫번째 방식으로는 로그 레벨이 맞지 않더라도 문자열 연산은 실행된다는 의미이다. 따라서, 무의미한 연산을 수행 방지를 위해 아래의 방식으로 로그를 생성하는 것이 좋다.

Logger을 이용해서 로그를 남기면 위와 같이, TIME, THREAD, CLASS 등의 정보가 함께 출력되어 로그 분석을 통해 필요한 정보들을 쉽게 얻어낼 수 있다. 또한, 콘솔 이외에도 파일, 네트워크, 등에 로그를 남기도록 설정할 수 있다.

또한, SLF4J 방식의 로거는 @Slf4j annotation을 명시하게 되면 롬복에서 Logger 객체를 자동으로 만든다.

## @RequestMappings

기존에, @RequestMapping을 통해 URL 매핑을 수행할 수 있던것을 확인했다. 이번에는 path variable이나, header, content-type 같은 특수한 경우에 대한 url 매핑을 수행해보자

> PathVariable

```java
@GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data){
    logger.info("mapping Path: {}",data);
    return "OK";
}
```

@PathVariable을 이용해서 받고자하는 parameter name을 명시한다.

/mapping/1로 request가 들어오면 --> userId 값에 1이 들어가게 된다.

> Multiple PathVariables

```java
@GetMapping("/mapping/users/{userId}/orders/{orderId}")
public String mappingPath(@PathVariable String userId, @PathVariable String orderId){
    logger.info("mapping Path userId={},orderId={}",userId,orderId);
    return "OK";
}
```
위와 같이 여러개의 parameter을 동시에 받을 수도 있다.

> Specific Parameter Mapping

```java
@GetMapping(value = "/mapping-param", params = "mode=debug")
public String mappingParam() {
    logger.info("mappingParam");
    return "ok";
}
```
params을 이용해서 특정 파라미터 조건을 명시한다.
/mapping-param?mode=debug 와 같이 query parameter을 전달하면 해당 메소드가 실행된다.

> Specific Header Mapping

```java
@GetMapping(value = "/mapping-header", headers = "mode=debug")
public String mappingHeader() {
    logger.info("mappingHeader");
    return "ok";
}
```
headers을 이용해서 헤더 조건 명시
http에 헤더에 mode=debug가 있으면 해당 메소드가 수행된다.

> Specific Media Type

```java
@PostMapping(value = "/mapping-consume", consumes = "application/json")
public String mappingConsumes() {
    logger.info("mappingConsumes");
    return "ok";
}
```
consumes을 이용해서 http request의 content-type 지정

content-type이 application/json인 http request를 받을 수 있다.

> Specific Accept Type

```java
@PostMapping(value = "/mapping-produce", produces = "text/html")
public String mappingProduces() {
    logger.info("mappingProduces");
    return "ok";
}
```

produces을 명시해서 해당 http response의 타입을 명시한다.

http request의 ACCESS Type이 text/html로 설정되어 있어야 해당 메소드를 수행할 수 있다.

## HTTP API Example

```java
@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {

    @GetMapping
    public String user(){
        return "get users";
    }
    @PostMapping
    public String addUser(){
        return "post user";
    }
    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId){
        return "get userId= "+userId;
    }
    @PatchMapping("/{userId}")
    public String patchUser(@PathVariable String userId){
        return "update userId="+userId;
    }
    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId){
        return "delete userId="+userId;
    }
}
```

다음과 같이 Annotation을 이용해서 각각의 HTTP Method에 대한 매핑을 수행할 수 있다. Spring MVC에서는 이 처럼 다양한 Annotation을 제공해서 개발자가 간편하게 개발할 수 있도록 지원한다.

## Http Requests

### Header 
서블릿에서는 HttpServletRequest 객체를 이용해서 header 정보를 추출할 수 있었다. Spring MVC에서는 어떻게 수행할까?

```java
@RestController
public class RequestHeaderController {
    @RequestMapping("/headers")
    public String headers(HttpServletRequest request, HttpServletResponse response, HttpMethod httpMethod, Locale locale, @RequestHeader MultiValueMap<String, String> headerMap, @RequestHeader("host") String host, @CookieValue(value = "myCookie", required = false) String cookie){
        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);
        return "ok";
    }
}
```

Spring MVC에서는 annotation을 기반으로 생성된 controller에 대해 다양한 파라미터를 제공한다.

- HttpMethod 객체를 이용해서 Http Method
- Locale 객체를 이용해서 Locale 정보를
- @RequestHeader을 이용해서 Header 정보를 
- @RequestHeader("header_option")를 이용해서 특정 헤더값을
- @Cookie을 이용해서 특정 쿠키값을

조회할 수 있다.

> MultiValueMap

Map과 유사하지만, Map과 달리 동일 키에 대해 복수개의 값을 저장할 수 있다.

keyA=value1&keyA=value2 와 같이 parameter 요청을 받았다고 하자
그러면, keyA에 대해 리스트값을 가지게 된다.

```java
MultiValueMap<String,String> map=new LinkedMultiValueMap();
map.add("keyA","value1");
map.add("keyA","value2");

map.get("keyA") ==> ["value1","value2]
```

### Request Parameters
GET, POST 방식으로 전송된 parameter는 key=value&key=value의 구조로 동일하다. 이런 parameter 요청을 어떻게 수용할까?

#### HttpServlet

```java
@RequestMapping("/request-param-v1")
public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String username = request.getParameter("username");
    int age = Integer.parseInt(request.getParameter("age"));

    log.info("log info= username:{} age:{}",username,age);
    response.getWriter().write("ok");
}
```
HttpServletRequest 객체를 이용해서 parameter을 조회할 수 있다.

#### @RequestParam

```java
@ResponseBody
@RequestMapping("/request-param-v2")
public String requestParamV2(@RequestParam("username") String username,@RequestParam("age") int age) throws IOException {
    log.info("log info= username:{} age:{}",username,age);
    return "ok";
}
```

@RequestParam을 이용해서 조회하고자 하는 parameter name을 명시한다.

```java
@ResponseBody
@RequestMapping("/request-param-v3")
public String requestParamV3(@RequestParam String username,@RequestParam int age) throws IOException {
    log.info("log info= username:{} age:{}",username,age);
    return "ok";
}
```
만약 변수 이름이 파라미터 이름과 같으면 @RequestParam name 옵션을 생략할 수 있다.

```java
@ResponseBody
@RequestMapping("/request-param-v4")
public String requestParamV4(String username,int age) throws IOException {
    log.info("log info= username:{} age:{}",username,age);
    return "ok";
}
```
만약 String, int 와 같은 기본타입이거나 Wrapper 클래스이면 @RequestParam도 생략할 수 있다.

```java
@ResponseBody
@RequestMapping("/request-param-required")
public String requestParamRequired(@RequestParam(required=true) String username,@RequestParam(required=false) Integer age) throws IOException {
    log.info("log info= username:{} age:{}",username,age);
    return "ok";
}
```
required 옵션을 추가해서 해당 파라미터의 필수 여부를 지정할 수 있다.
위와같은 경우 
/request-param-required?username=hello 와 같이 명시해도 요청을 받아 들일 수 있다. 이때, 주의할 점이 있는데, 파라미터가 전달되지 않는 경우 null값으로 저장되기 때문에 int와 같은 기본타입에는 null이 저장되지 않으므로 Integer와 같은 Wrapper 클래스를 활용해야한다.

username= 와 같이 전달하게 되면 "" 빈문자열이 저장된다.

```java
@ResponseBody
@RequestMapping("/request-param-default")
public String requestParamDefault(@RequestParam(required=true, defaultValue = "guest") String username,@RequestParam(required=false,defaultValue = "-1") int age) throws IOException {
    log.info("log info= username:{} age:{}",username,age);
    return "ok";
}
```
defaultValue 옵션을 이용해서 파라미터가 전달되지 않았을 때 설정할 수 있는 기본값을 지정할 수 있다. defaultValue가 설정되어 있는 required는 무시되게 된다.

```java
@ResponseBody
@RequestMapping("/request-param-map")
public String requestParamMap(@RequestParam Map<String,Object> paramMap) throws IOException {
    log.info("log info= username:{} age:{}",paramMap.get("username"),paramMap.get("age"));
    return "ok";
}
```
위와 같이 Map 형태로 parameter을 받을 수 있다.

```java
@ResponseBody
@RequestMapping("/request-param-multivaluemap")
public String requestParamMultiValueMap(@RequestParam MultiValueMap<String, Object> paramMap) throws IOException {
    log.info("log info= username:{} age:{}",paramMap.get("username"),paramMap.get("age"));
    return "ok";
}
```
Map 대신 MultiValueMap을 활용할 수 있다.

#### @ModelAttribute

파라미터에 대해서 객체 형태로 받아서 객체에 대해 접근을 할 수 있다.

```java
package hello.springmvc.basic;
import lombok.Data;
@Data
public class HelloData {
    private String username;
    private int age;
}
```
Lombok 의 @Data annotation을 이용하면 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor annotation을 적용한다.


```java
@ResponseBody
@RequestMapping("/model-attribute-v1")
public String modelAttributeV1(@ModelAttribute HelloData helloData){
    log.info("log info= username:{} age:{}",helloData.getUsername(),helloData.getAge());
    return "ok";
}
```
@ModelAttribute을 이용해서 객체 형태로 데이터를 받는 것이 가능하다. Spring MVC에서 객체를 생성하고, setter을 이용해서 값을 저장한다.

HelloData의 age에는 int 데이터가 추가되야 하는데, 만약 "abc" 와 같은 string 형태의 데이터가 요청으로 들어오면 **BindException** 에러가 발생한다.


```java
@ResponseBody
@RequestMapping("/model-attribute-v2")
public String modelAttributeV2(HelloData helloData){
    log.info("log info= username:{} age:{}",helloData.getUsername(),helloData.getAge());
    return "ok";
}
```

Model Attribute에 지정한 파라미터 클래스의 필드 타입이 단순형이면 @ModelAttribute annotation도 생략할 수 있다. 단, argument resolver로 지정해둔 타입외에서만 적용된다.


@RequestParam, @ModelAttribute이 모두 생략되어 있으면, 우선적으로 단순 타입의 경우 @RequestParam이 적용되고, 나머지에 대해서 @ModelAttribute이 적용된다.

### HTTP Message Body



## References
link: [inflearn](https://www.inflearn.com/roadmaps/373)

link:[springcore](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/)

